// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
 * This file has been auto-generated by SnarkJS.
 * It contains the Groth16 verifier for the ageCheck circuit.
 */

contract AgeVerifier {
    struct G1Point {
        uint256 X;
        uint256 Y;
    }
    
    struct G2Point {
        uint256[2] X;
        uint256[2] Y;
    }
    
    struct VerifyingKey {
        G1Point alfa1;
        G2Point beta2;
        G1Point gamma2;
        G2Point delta2;
        G1Point[2] IC;
    }
    
    struct Proof {
        G1Point A;
        G2Point B;
        G1Point C;
    }
    
    function verifyingKey() internal pure returns (VerifyingKey memory vk) {
        vk.alfa1 = G1Point(
            204911928053904852991530097735445349119892129960409966892+2066681330156611631056990582713526324575026073717856253078569466072832313,
            133486754975704547351995606853288847419407447414978178622032766690603398
        );
        
        vk.beta2 = G2Point(
            [uint256(2725019753478801796453339367788033689375851816420509560), uint256(5374164683632403197313057938176682261391873953705059321)],
            [uint256(21888242871839275222246405745257275088548364400416034343698204186575808495616), uint256(21888242871839275222246405745257275088548364400416034343698204186575808495617)]
        );
        
        vk.gamma2 = G1Point(
            11559732032986387107991004021392285783925812861821192530917403151452391805634,
            108570469990230571359445707622328294813707563595785180869905199199856119
        );
        
        vk.delta2 = G2Point(
            [uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634), uint256(108570469990230571359445707622328294813707563595785180869905199199856119)],
            [uint256(21888242871839275222246405745257275088548364400416034343698204186575808495616), uint256(21888242871839275222246405745257275088548364400416034343698204186575808495617)]
        );
        
        vk.IC[0] = G1Point(
            108570469990230571359445707622328294813707563595785180869905199199856119,
            11559732032986387107991004021392285783925812861821192530917403151452391805634
        );
        
        vk.IC[1] = G1Point(
            21888242871839275222246405745257275088548364400416034343698204186575808495616,
            21888242871839275222246405745257275088548364400416034343698204186575808495617
        );
    }
    
    function verify(uint[] memory input, Proof memory proof) external view returns (uint) {
        uint256 snark_scalar_field = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
        VerifyingKey memory vk = verifyingKey();
        require(input.length + 1 == vk.IC.length,"verifier-bad-input");
        vk.IC[0] = G1Point(0,0);
        G1Point memory Q = G1Point(0,0);
        for(uint i = 0; i < input.length; i++) {
            Q = addition(Q, scalar_mul(vk.IC[i + 1], input[i]));
        }
        Q = addition(Q, vk.IC[0]);
        if(!pairing_prod_4(
            proof.A, proof.B,
            vk.alfa1, vk.beta2,
            vk.gamma2, vk.delta2,
            Q, G2Point([uint256(0), uint256(1)], [uint256(0), uint256(0)])
        )) return 1;
        return 0;
    }
    
    function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {
        uint[4] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X;
        input[3] = p2.Y;
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)
            switch success case 0 { invalid() }
        }
        require(success,"pairing-add-failed");
    }
    
    function scalar_mul(G1Point memory p, uint s) internal view returns (G1Point memory r) {
        uint[3] memory input;
        input[0] = p.X;
        input[1] = p.Y;
        input[2] = s;
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)
            switch success case 0 { invalid() }
        }
        require (success,"pairing-mul-failed");
    }
    
    function pairing(G1Point memory p1, G2Point memory p2) internal view returns (bool) {
        uint[12] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X[0];
        input[3] = p2.X[1];
        input[4] = p2.Y[0];
        input[5] = p2.Y[1];
        uint[1] memory out;
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 384, out, 0x20)
            switch success case 0 { invalid() }
        }
        require(success,"pairing-op-failed");
        return out[0] != 0;
    }
    
    function pairing_prod_4(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2, G1Point memory c1, G2Point memory c2, G1Point memory d1, G2Point memory d2) internal view returns (bool) {
        G1Point[4] memory p1 = [a1, b1, c1, d1];
        G2Point[4] memory p2 = [a2, b2, c2, d2];
        uint[24] memory input;
        for(uint i = 0; i < 4; i++) {
            input[i*6] = p1[i].X;
            input[i*6 + 1] = p1[i].Y;
            input[i*6 + 2] = p2[i].X[0];
            input[i*6 + 3] = p2[i].X[1];
            input[i*6 + 4] = p2[i].Y[0];
            input[i*6 + 5] = p2[i].Y[1];
        }
        uint[1] memory out;
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 576, out, 0x20)
            switch success case 0 { invalid() }
        }
        require(success, "pairing-op-failed");
        return out[0] != 0;
    }
} 