const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ProofRegistry", function () {
  let proofRegistry;
  let ageVerifier;
  let owner;
  let user1;
  let user2;

  beforeEach(async function () {
    [owner, user1, user2] = await ethers.getSigners();

    // Deploy AgeVerifier first
    const AgeVerifier = await ethers.getContractFactory("AgeVerifier");
    ageVerifier = await AgeVerifier.deploy();
    await ageVerifier.deployed();

    // Deploy ProofRegistry with AgeVerifier address
    const ProofRegistry = await ethers.getContractFactory("ProofRegistry");
    proofRegistry = await ProofRegistry.deploy(ageVerifier.address);
    await proofRegistry.deployed();
  });

  describe("Deployment", function () {
    it("Should set the correct verifier address", async function () {
      expect(await proofRegistry.verifier()).to.equal(ageVerifier.address);
    });

    it("Should have the correct owner", async function () {
      expect(await proofRegistry.owner()).to.equal(owner.address);
    });
  });

  describe("Proof Verification", function () {
    it("Should emit ProofVerified event on successful verification", async function () {
      // Mock proof data (in real scenario, this would be generated by SnarkJS)
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")]; // 1 indicates age >= 18

      // Mock the verifier to return success (0)
      await ageVerifier.mock.verify.returns(0);

      await expect(proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals))
        .to.emit(proofRegistry, "ProofVerified")
        .withArgs(user1.address, await ethers.provider.getBlock("latest").then(block => block.timestamp));
    });

    it("Should not allow duplicate verification", async function () {
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")];

      // Mock the verifier to return success
      await ageVerifier.mock.verify.returns(0);

      // First verification should succeed
      await proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals);

      // Second verification should emit ProofAlreadyVerified
      await expect(proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals))
        .to.emit(proofRegistry, "ProofAlreadyVerified")
        .withArgs(user1.address);
    });

    it("Should emit ProofVerificationFailed for invalid proof", async function () {
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("0")]; // 0 indicates age < 18

      // Mock the verifier to return failure (1)
      await ageVerifier.mock.verify.returns(1);

      await expect(proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals))
        .to.emit(proofRegistry, "ProofVerificationFailed")
        .withArgs(user1.address, "Invalid proof");
    });
  });

  describe("Status Queries", function () {
    it("Should return correct verification status", async function () {
      expect(await proofRegistry.isVerified(user1.address)).to.be.false;

      // Mock successful verification
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")];

      await ageVerifier.mock.verify.returns(0);
      await proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals);

      expect(await proofRegistry.isVerified(user1.address)).to.be.true;
    });

    it("Should return correct verification timestamp", async function () {
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")];

      await ageVerifier.mock.verify.returns(0);
      
      const tx = await proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals);
      const receipt = await tx.wait();
      const block = await ethers.provider.getBlock(receipt.blockNumber);

      expect(await proofRegistry.getVerificationTimestamp(user1.address)).to.equal(block.timestamp);
    });

    it("Should return correct verification status and timestamp", async function () {
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")];

      await ageVerifier.mock.verify.returns(0);
      
      const tx = await proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals);
      const receipt = await tx.wait();
      const block = await ethers.provider.getBlock(receipt.blockNumber);

      const [verified, timestamp] = await proofRegistry.getVerificationStatus(user1.address);
      expect(verified).to.be.true;
      expect(timestamp).to.equal(block.timestamp);
    });
  });

  describe("Edge Cases", function () {
    it("Should handle verification failure gracefully", async function () {
      const mockProof = {
        A: { X: ethers.utils.parseEther("1"), Y: ethers.utils.parseEther("2") },
        B: { 
          X: [ethers.utils.parseEther("3"), ethers.utils.parseEther("4")], 
          Y: [ethers.utils.parseEther("5"), ethers.utils.parseEther("6")] 
        },
        C: { X: ethers.utils.parseEther("7"), Y: ethers.utils.parseEther("8") }
      };

      const mockPublicSignals = [ethers.utils.parseEther("1")];

      // Mock the verifier to revert
      await ageVerifier.mock.verify.revertsWith("Verification failed");

      await expect(proofRegistry.connect(user1).verifyAndStoreProof(mockProof, mockPublicSignals))
        .to.emit(proofRegistry, "ProofVerificationFailed")
        .withArgs(user1.address, "Verification reverted");
    });

    it("Should not allow verification with invalid verifier address", async function () {
      const ProofRegistry = await ethers.getContractFactory("ProofRegistry");
      
      await expect(ProofRegistry.deploy(ethers.constants.AddressZero))
        .to.be.revertedWith("Invalid verifier address");
    });
  });
}); 